<!DOCTYPE html>
<html>
  <head>
    <style type="text/css">
@import url('https://fonts.googleapis.com/css?family=Dosis');

body {
    color: #333;
    font-family: Verdana, Geneva, Tahoma, sans-serif;
}

.remark-slide-content h1 {
    font-size: 1.4em;
    margin-bottom: 0.5em;
}

.remark-slide-content h2 {
    font-size: 1.7em;
    margin-bottom: 0.2em;
}

.nastiness {
    display: block;
    font-family: 'Dosis', cursive;
    font-size: 1.1em;
    position: absolute;
    transform: rotate(-7deg);
    top: 4%;
    left: 80%;
}

.remark-slide-content table {
    border-collapse: collapse;
}

.remark-slide-content table td, .remark-slide-content table th {
    border: 1px solid black;
    padding: 0.5em;
}

.nastiness::before {
    content: "Nastiness: ";
}

    </style>
  </head>
  <body>
     <textarea id="source">
class: center, middle

# Mistakes to avoid when writing a Rust wrapper around a C library

A collection of mistakes people often make.
<br />
<small>And that I also made.<br /><small>In no precise order.</small></small>

<div style="position: absolute; bottom: 5%; right: 5%;">
.right[
    twitter.com/tomaka17 <img src="twitter.png" alt="Twitter" height="16" /><br />
    github.com/tomaka <img src="github.png" alt="GitHub" height="16" /><br />
]
</div>

---

## Mistake #1
# Not catching panics in callbacks

.nastiness[<span style="color: #00BB00;">low</span>]

*Rule*: It is undefined behaviour to panic within a callback.<br />
Example:

```rust
extern "C" fn callback() {
    panic!("Oops");     // Will likely segfault
}

c_library_set_callback(callback);
```

Therefore this is dangerous:

```rust
extern "C" fn callback() {
    dispatch_to_a_user_provided_function();
}
```

If the user-provided function happens to panic, then your library will trigger an undefined
behaviour.

---

## Mistake #1
# Not catching panics in callbacks

.nastiness[<span style="color: #00BB00;">low</span>]

Instead:

```rust
use std::panic;
extern "C" fn callback() {
    panic::catch_unwind(|| {
        panic!("Oops");
    });
}
```

---

## Mistake #2
# Assuming that trait implementations are bug-free

.nastiness[<span style="color: #BBBB00;">medium</span>]

Try to spot the problem:

```rust
extern {
    // `pointer` must be an array of `len` elements
    fn foo(pointer: *const c_char, len: size_t);
}

pub fn foo_wrapper<T>(array_arg: &T)
    where T: Deref<[u8]>
{
    unsafe {
        foo(
            array_arg.as_ptr() as *const c_char,
            array_arg.len()
        );
    }
}
```

---

## Mistake #2
# Assuming that trait implementations are bug-free

.nastiness[<span style="color: #BBBB00;">medium</span>]

What if I call `foo_wrapper()` with a `MaliciousPointer`?

```rust
struct MaliciousPointer {
    vec1: Vec<u8>,
    vec2: Vec<u8>,
}

impl Deref for MaliciousPointer {
    type Target = [u8];
    fn deref(&self) -> &[u8] {
        if random() < 0.5 { &self.vec1 }
        else { &self.vec2 }
    }
}
```

```rust
let malicious = MaliciousPointer {
    vec1: vec![3, 8],
    vec2: vec![12, 9, 37],
};
foo_wrapper(&malicious);
```

---

## Mistake #2
# Assuming that trait implementations are bug-free

.nastiness[<span style="color: #BBBB00;">medium</span>]

What if I call `foo_wrapper()` with a `MaliciousPointer`?

```rust
pub fn foo_wrapper<T: Deref<[u8]>>(array_arg: &T) {
    unsafe {
        foo(
            // could pass a pointer to the first Vec ...
            array_arg.as_ptr() as *const c_char,
            // ... but with the length of the second Vec
            array_arg.len()
        );
    }
}
```

Ouch!

---

## Mistake #2
# Assuming that trait implementations are bug-free

.nastiness[<span style="color: #BBBB00;">medium</span>]

Important to note:

In this example, it was a *malicious* implementation of `Deref`.
In a real program, it could be an actual bug that becomes potentially exploitable.

---

## Mistake #3
# Try to write a high-level API first

People will complain about features of the C library that you don't expose.

---

## Mistake #4
# Leak safety

.nastiness[<span style="color: #BB0000;">high</span>]

---

## Mistake #5
# Forgetting about hidden global variables

.nastiness[<span style="color: #BBBB00;">medium</span>]

Example: *OpenAL*, a sound playback library.

```rust
extern {
    // Sets the current context. Only one context can be current
    // at any given time. All commands apply to the current context.
    fn alcMakeContextCurrent(ctxt: *mut ALCcontext) -> ALCboolean;
}
```

This is a global variable hidden inside the OpenAL library!

This design is not thread-safe (at all). None of the possible work-arounds is perfectly safe.<br />
*OpenAL* **cannot** be wrapped safely, because of its design.

<hr />

Other examples: OpenGL, POSIX signals, Xlib (`XSetErrorHandler`), ...

???

In order to use OpenAL, you first create what is called a "context" and set this context as
current. Then all the functions that you call apply on the current context.

If you think about it, the variable that stores the "current context" is essentially a global
variable.

This is a problematic design, because two threads can't safely operate on two different contexts.
If you're performing some operations on thread 1, and in the meanwhile thread 2 changes the current
context by calling `alcMakeContextCurrent` then it will change the behaviour of thread 1.

There are work-arounds, but none of them is perfectly safe.

So, there's just no solution. OpenAL cannot be wrapped safely.

Many libraries have this kind of design and can be safely wrapped around, but some can't. Be aware
of this.

---

## Mistake #6
# Using lifetimes for long-lived objects

*Situation:* the library requires that object `B` outlives object `A`.

*What people sometimes do:* store a `&A` inside of `B`.

```rust
struct B<'a> {
    parent: &'a A,
}
```

---

## Mistake #6
# Using lifetimes for long-lived objects

*Situation:* the library requires that object `B` outlives object `A`.

*What people sometimes do:* store a `&A` inside of `B`.

```rust
struct B<'a> {
    parent: &'a A,
}
```

Unfortunately, lifetimes are more restrictive than just "outlives".

```rust
struct HighLevelCode {
    parent: A,
    child: B<???>,      // impossible to write
}
```

---

## Mistake #7
# Reading primitives from memory without checking

.nastiness[<span style="color: #00BB00;">low</span>]

Concerned: `f32`s, `f64`s, `bool`s and `char`s

```rust
// can be undefined behaviour!
let b: char = unsafe { mem::uninitialized() };

// actually undefined behaviour (bad!)
let b: f32 = unsafe { mem::transmute(0x7f800001) };
```

Rules:
- `bool`s must always be either `0` or `1` <small>(actually, this is unspecified)</small>.
- `char`s must be a valid unicode scalar value</small>.
- Floating-points must never contain signalling NaNs.

???

By extension, arrays and structs that contain these types are also concerned.

You must make sure that these rules are enforced when you transmute.

---

## Mistake #8
# Assuming that structs and enums have a certain layout

.nastiness[<span style="color: #BBBB00;">medium</span>]

Example:

```rust
struct Foo {
    a: u8,
    b: u32,
}
```

The compiler can optimize this struct's layout, and `a` may end up being **after** `b` in memory.

Use `#[repr(C)]` to force the layout.

```rust
#[repr(C)]
struct Foo {
    a: u8,
    b: u32,
}
```

???

The compiler will warn you if you try to call an external function with a struct that isn't
`repr(C)`. But it won't warn you if you perform transmutes or pointer casts.

---

## Mistake #9
# Being too strict in your trait requirements

---

## Mistake #10
# Not using your own library

---
class: center, middle

# Conclusion

**Read the rustonomicon: https://doc.rust-lang.org/nomicon/**

If you feel overwhelmed, think about the fact that safe Rust protects against all these
problems.

---
class: center, middle

# Thank you

<div style="position: absolute; bottom: 5%; right: 5%;">
.right[
    twitter.com/tomaka17 <img src="twitter.png" alt="Twitter" height="16" /><br />
    github.com/tomaka <img src="github.png" alt="GitHub" height="16" /><br />
]
</div>

<div style="position: absolute; bottom: 5%; left: 5%;">
.left[
    <img src="patreon.svg" alt="Patreon.com" height="16" /> patreon.com/tomaka<br />
    <small>(by the way, I'm looking for a job)</small>
]
</div>

???

That's it! Thank you!

    </textarea>
     <script src="remark.min.js">
    </script>
    <script>
       var slideshow = remark.create();
    </script>
  </body>
</html>


