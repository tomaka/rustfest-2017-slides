<!DOCTYPE html>
<html>
  <head>
    <style type="text/css">
@import url('https://fonts.googleapis.com/css?family=Dosis');

body {
    color: #333;
    font-family: Verdana, Geneva, Tahoma, sans-serif;
}

.remark-slide-content h1 {
    font-size: 1.4em;
    margin-bottom: 0.5em;
}

.remark-slide-content h2 {
    font-size: 1.7em;
    margin-bottom: 0.2em;
}

.nastiness {
    display: block;
    font-family: 'Dosis', cursive;
    font-size: 1.1em;
    position: absolute;
    transform: rotate(-7deg);
    top: 4%;
    left: 80%;
}

.nastiness::before {
    content: "Nastiness: ";
}

    </style>
  </head>
  <body>
     <textarea id="source">
class: center, middle

# Advices and common mistakes when writing your Rust wrapper around a C library

<div style="position: absolute; bottom: 5%; right: 5%;">
.right[
    twitter.com/tomaka17 <img src="twitter.png" alt="Twitter" height="16" /><br />
    github.com/tomaka <img src="github.png" alt="GitHub" height="16" /><br />
]
</div>

---

# Introduction

People write wrappers around C libraries.

Rust has rules. When you call C code, you must enforce these rules yourself. Unfortunately people
make mistakes when trying to enforce these rules.

---

## Mistake #1
# Leak safety

.nastiness[<span style="color: #BB0000;">high</span>]

---

## Mistake #2
# Catching panics in variables

---

## Mistake #3
# Assuming that trait implementations are bug-free

.nastiness[<span style="color: #BBBB00;">medium</span>]

Try to spot the problem:

```rust
fn foo<T: Deref<String>>(string_arg: &T) {
    unsafe {
        let mut vec = Vec::with_capacity(string_arg.len());
        ptr::copy(string_arg.as_ptr(), vec.as_mut_ptr(),
                  string_arg.len());
        dst.set_len(string_arg.len());

        // ... do something with the Vec
    }
}
```

Hint:

```rust
let a = string_arg.len();
let b = string_arg.len();
// a == b ?
```

---

## Mistake #3
# Assuming that trait implementations are bug-free

.nastiness[<span style="color: #BBBB00;">medium</span>]

What if I call `foo()` with a `MaliciousPointer`?

```rust
struct MaliciousPointer {
    string1: String,
    string2: String,
}

impl Deref for MaliciousPointer {
    type Target = String;
    fn deref(&self) -> &String {
        if random() < 0.5 { &self.string1 }
        else { &self.string2 }
    }
}
```

---

## Mistake #4
# Hidden global variables

.nastiness[<span style="color: #BBBB00;">medium</span>]

Example: *OpenAL*, a sound playback library.

```rust
extern {
    // Sets the current context. Only one context can be current
    // at any given time. All commands apply to the current context.
    fn alcMakeContextCurrent(ctxt: *mut ALCcontext) -> ALCboolean;
}
```

This is a global variable hidden inside the OpenAL library!

This design is not thread-safe (at all). None of the possible work-arounds is perfectly safe.<br />
*OpenAL* **cannot** be wrapped safely, because of its design.

<hr />

Other examples: OpenGL, POSIX signals, Xlib (`XSetErrorHandler`), ...

???

In order to use OpenAL, you first create what is called a "context" and set this context as
current. Then all the functions that you call apply on the current context.

If you think about it, the variable that stores the "current context" is essentially a global
variable.

This is a problematic design, because two threads can't safely operate on two different contexts.
If you're performing some operations on thread 1, and in the meanwhile thread 2 changes the current
context by calling `alcMakeContextCurrent` then it will change the behaviour of thread 1.

There are work-arounds, but none of them is perfectly safe.

So, there's just no solution. OpenAL cannot be wrapped safely.

Many libraries have this kind of design and can be safely wrapped around, but some can't. Be aware
of this.

---

## Mistake #5
# Reading some primitives can cause undefined behaviour

.nastiness[<span style="color: #00BB00;">low</span>]

Concerned: `f32`s, `f64`s, `bool`s and `char`s

```rust
// can be undefined behaviour!
let b: char = unsafe { mem::uninitialized() };

// actually undefined behaviour (bad!)
let b: f32 = unsafe { mem::transmute(0x7f800001) };
```

Rules:
- `bool`s must always be either `0` or `1` <small>(actually, this is unspecified)</small>.
- `char`s must be a valid unicode scalar value</small>.
- Floating-points must never contain signalling NaNs.

???

By extension, arrays and structs that contain these types are also concerned.

You must make sure that these rules are enforced when you transmute.

---

## Mistake #6
# Assuming that structs and enums have a certain layout

.nastiness[<span style="color: #BBBB00;">medium</span>]

Example:

```rust
struct Foo {
    a: u8,
    b: u32,
}
```

The compiler can optimize this struct's layout, and `a` may end up being **after** `b` in memory.

Use `#[repr(C)]` to force the layout.

```rust
#[repr(C)]
struct Foo {
    a: u8,
    b: u32,
}
```

???

The compiler will warn you if you try to call an external function with a struct that isn't
`repr(C)`. But it won't warn you if you perform transmutes or pointer casts.

---
class: center, middle

Some advices about API design

---

## Advice #1
# Use lifetimes only for temporary objects

*Situation:* the library requires that object `B` outlives object `A`.

*What people sometimes do:* store a `&A` inside of `B`.

```rust
struct B<'a> {
    parent: &'a A,
}
```

---

## Advice #1
# Use lifetimes only for temporary objects

*Situation:* the library requires that object `B` outlives object `A`.

*What people sometimes do:* store a `&A` inside of `B`.

```rust
struct B<'a> {
    parent: &'a A,
}
```

Unfortunately, lifetimes are more restrictive than just "outlives".

```rust
struct HighLevelCode {
    parent: A,
    child: B<???>,      // impossible to write
}
```

---

## Advice #2
# Don't try to write an easy-to-use API

---

## Advice #3
# Don't be too strict in your trait requirements

---
class: center, middle

# Conclusion

**Read the rustonomicon: https://doc.rust-lang.org/nomicon/**

If you feel overwhelmed, think about the fact that safe Rust protects against all these
problems.

---
class: center, middle

# Thank you

<div style="position: absolute; bottom: 5%; right: 5%;">
.right[
    twitter.com/tomaka17 <img src="twitter.png" alt="Twitter" height="16" /><br />
    github.com/tomaka <img src="github.png" alt="GitHub" height="16" /><br />
]
</div>

<div style="position: absolute; bottom: 5%; left: 5%;">
.left[
    <img src="patreon.svg" alt="Patreon.com" height="16" /> patreon.com/tomaka<br />
    <small>(by the way, I'm looking for a job)</small>
]
</div>

???

That's it! Thank you!

    </textarea>
     <script src="remark.min.js">
    </script>
    <script>
       var slideshow = remark.create();
    </script>
  </body>
</html>


